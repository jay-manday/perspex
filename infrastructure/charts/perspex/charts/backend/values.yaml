replicaCount: 1
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""
environment: ""

helmTest:
  enabled: false
  path: "/"

image:
  repository: "registry.local:5000/backend"
  pullPolicy: Always
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"
  policyMarker: '# {"$imagepolicy": "flux-system:backend:tag"}'

serviceAccount:
  create: true
  annotations: {}
  name: ""

# DO NOT EDIT - To be passed in by parent chart
global:
  config:
    auth0: {}
    aws: {}
    backend: {}
    google: {}
    export: {}
    ingestion: {}
    database: {}
    dynamo: {}
    redis: {}
    kafka: {}
    sqsTopic: {}
config:
  auth0:
    domain: "1build-stagings.auth0.com"
    issuer: "1build-stagings.auth0.com"
  aws:
    endpoint: ""
  backend:
    gqlPath: "/api/graphql"
    scheme: "http"
    host: "backend"
    ingestionPool: 12
    cutomerTrialPeriod: 7
  kafka: 
    enabled: false
    brokers: ""
  google:
    bqProjectID: "onebuild-1566453616550"
    bqPrivateKeyID: "ba718ae75133a285ebfdca8962bb9a1eb5e158d6"
    bqClientEmail: "backend-bigquery-integration@onebuild-1566453616550.iam.gserviceaccount.com"
    bqClientID: "104478768359491634681"
    bqClientX509CertURL: "https://www.googleapis.com/robot/v1/metadata/x509/backend-bigquery-integration%40onebuild-1566453616550.iam.gserviceaccount.com"
  dataLakeBucket: "1b-development-lake"
  s3PlanBucket: "1b-development-ingestion"
  sqsTopic:
    export: "1b-development-export"
    exportCollation: "1b-development-export-collation-normal"
    predictor: "1b-development-predictor"
    predictorProjectPricing: "1b-development-predictor-project-pricing-normal"
    ingestion: "1b-development-ingestion"
  dynamo:
    exportTable: "1b-development-export"
    assetTable: "1b-development-asset"
  database:
    host: "portal-postgresql"
    port: 5432
    user: "postgres"
    db: "pg"
    schema: "public"
    maxIdleConnections: 128
    maxOpenConnections: 4096
    connectionLifespan: 128
    debug: false
  redis:
    host: "portal-redis-master"
    port: 6379
    tls: false
    skipVerify: false
healthcheck:
  liveness:
    enabled: true
    # Defaults to tcpSocket on the service.port if disabled
    http:
      enabled: true
      path: "/api/status"
    periodSeconds: 30
    initialDelaySeconds: 15
    failureThreshold: 3
  readiness:
    enabled: true
    # Defaults to tcpSocket on service.port if disabled
    http:
      enabled: true
      path: "/api/status"
    periodSeconds: 30
    initialDelaySeconds: 15
    failureThreshold: 3

# Enable or disable secrets from AWS SecretsManager
secretsManager:
  enabled: false
  secretName: "backend-secrets"
  createSecret: false

# Flagger canary or A/B settings
canary:
  # canary.enabled -- Should the application use Flagger for progressive delivery?
  enabled: false
  type: "A/B"
  headerValue: "insider"
  matchHeaders:
    - headers:
        x-canary:
          exact: "insider"
  provider: "contour"
  # Only used with nginx provider
  ingressRef:
    name: "portal-backend"
    apiVersion: networking.k8s.io/v1beta1
    kind: Ingress
  analysis:
    # canary.analysis.interval -- Flagger metric check interval
    interval: 15s
    # canary.analysis.threshold -- Max number of failed metric checks before rollback
    threshold: 10
    # canary.analysis.iterations -- Number of iterations to run before promotion happens
    iterations: 10
    maxWeight: 50
    stepWeight: 10
  retries:
    timeout: 15s
    attempts: 3
    perTryTimeout: 5s
  defaultMetrics:
    enabled: false
    metrics:
    - name: request-success-rate
      interval: 1m
      # minimum req success rate (non 5xx responses)
      # percentage (0-100)
      thresholdRange:
        min: 99
    - name: request-duration
      interval: 1m
      # maximum req duration P99
      # milliseconds
      thresholdRange:
        max: 500
  # canary.customMetrics -- Custom metrics to use to evaluate if a deployment should be promoted
  customMetrics:
    enabled: false
    metrics:
    - name: error-rate
      namespace: portal
      maxThreshold: 1
      interval: 1m
  loadtest:
    # canary.loadtest.enabled -- Enable loadtesting for the canary deployments - will run `hey` against an API endpoint that you specified to generate metric data for evaluation (pairs with customMetrics)
    enabled: true
    # canary.loadtest.url -- Load tester address to use (where the actual load test command is run, NOT the url to test)
    url: http://loadtester.flagger/
    # canary.loadtest.path -- Application HTTP path to use for loadtesting against
    path: "/api/status"
  helmtest:
    # canary.helmtest.enabled -- Enable `helm test` step during deployment to make sure the chart works as expected
    enabled: false
    # helm tester address to use (where the actual helm test command is run, NOT the url to test)
    url: http://helmtester.flagger/

podAnnotations: {}

podSecurityContext: {}

securityContext: {}

service:
  type: ClusterIP
  port: 8080

traefik:
  enabled: false
  path: "/api"
  host: "svc.development.1build.com"
  # Middlewares managed in flux as they're shared in most cases
  middlewares:
    - name: cors-configuration
      namespace: portal
  entrypoints:
    - web
  # Should adhere to Traefik's Rule kind spec
  additionalRoutes: []

contour:
  enabled: false
  host: ""
  routes:
    - prefix: "/api"

ingress:
  enabled: false
  annotations: {}
  #hosts:
  #  - host: backend
  #    paths: []
  #tls: []

resources: {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 20
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}
